{
  "name": "Python Programming Fundamentals",
  "description": "Essential Python concepts including data structures, functions, and object-oriented programming",
  "cards": [
    {
      "question": "What is a list in Python?",
      "hint": "It's a built-in mutable data structure",
      "options": [
        "A key-value pair structure",
        "An ordered, mutable collection of items",
        "A function decorator",
        "A class attribute"
      ],
      "correct_answer": 1,
      "description": "A list is an ordered, mutable collection that can contain items of different types. Lists are defined using square brackets [] and support operations like append, remove, and slicing.",
      "reference": "https://docs.python.org/3/tutorial/datastructures.html",
      "code": "my_list = [1, 2, 3, 'four', 5.0]\nprint(my_list[0])  # Output: 1\nmy_list.append(6)\nprint(len(my_list))  # Output: 6"
    },
    {
      "question": "What does the 'with' statement do in Python?",
      "hint": "Think about resource management",
      "options": [
        "Creates a new module",
        "Defines a context manager for automatic resource cleanup",
        "Imports external libraries",
        "Declares a global variable"
      ],
      "correct_answer": 1,
      "description": "The 'with' statement is used with context managers to ensure proper resource management. It automatically handles setup and cleanup operations, like closing files or releasing locks, even if an exception occurs.",
      "reference": "https://docs.python.org/3/reference/compound_stmts.html#with",
      "code": "# File is automatically closed after the block\nwith open('file.txt', 'r') as f:\n    content = f.read()\n    print(content)\n# File is already closed here"
    },
    {
      "question": "What is the difference between '==' and 'is' in Python?",
      "hint": "One checks value, the other checks identity",
      "options": [
        "They are exactly the same",
        "'==' checks value equality, 'is' checks object identity",
        "'==' is for numbers, 'is' is for strings",
        "'is' is deprecated in Python 3"
      ],
      "correct_answer": 1,
      "description": "'==' compares the values of two objects for equality, while 'is' checks if two references point to the same object in memory. Use '==' for value comparison and 'is' for identity comparison (like checking for None).",
      "reference": "https://docs.python.org/3/reference/expressions.html#comparisons",
      "code": "a = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)  # True (same values)\nprint(a is b)  # False (different objects)\nprint(a is c)  # True (same object)"
    },
    {
      "question": "What is a lambda function in Python?",
      "hint": "It's a way to create small functions",
      "options": [
        "A built-in mathematical function",
        "An anonymous, inline function defined with the lambda keyword",
        "A type of loop",
        "A class method"
      ],
      "correct_answer": 1,
      "description": "Lambda functions are small anonymous functions defined using the lambda keyword. They can have any number of parameters but only one expression. They're often used for short, simple operations passed as arguments to higher-order functions.",
      "reference": "https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions",
      "code": "# Regular function\ndef square(x):\n    return x ** 2\n\n# Lambda equivalent\nsquare_lambda = lambda x: x ** 2\n\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x ** 2, numbers))\nprint(squared)  # [1, 4, 9, 16, 25]"
    },
    {
      "question": "What is list comprehension in Python?",
      "hint": "It's a concise way to create lists",
      "options": [
        "A debugging tool for lists",
        "A concise syntax for creating new lists from existing iterables",
        "A method to compress lists",
        "A way to document list usage"
      ],
      "correct_answer": 1,
      "description": "List comprehension provides a concise way to create lists. It consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The result is a new list resulting from evaluating the expression.",
      "reference": "https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions",
      "code": "# Traditional approach\nsquares = []\nfor x in range(10):\n    squares.append(x**2)\n\n# List comprehension\nsquares = [x**2 for x in range(10)]\n\n# With condition\neven_squares = [x**2 for x in range(10) if x % 2 == 0]"
    },
    {
      "question": "What is the purpose of *args and **kwargs in Python?",
      "hint": "They're used in function definitions for flexible arguments",
      "options": [
        "To multiply arguments",
        "To accept variable numbers of positional and keyword arguments",
        "To create decorators",
        "To define class attributes"
      ],
      "correct_answer": 1,
      "description": "*args allows a function to accept any number of positional arguments as a tuple. **kwargs allows a function to accept any number of keyword arguments as a dictionary. They provide flexibility when you don't know in advance how many arguments will be passed.",
      "reference": "https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists",
      "code": "def example_function(*args, **kwargs):\n    print('Positional args:', args)\n    print('Keyword args:', kwargs)\n\nexample_function(1, 2, 3, name='Alice', age=30)\n# Output:\n# Positional args: (1, 2, 3)\n# Keyword args: {'name': 'Alice', 'age': 30}"
    },
    {
      "question": "What is a decorator in Python?",
      "hint": "It modifies or enhances functions",
      "options": [
        "A design pattern for classes",
        "A function that modifies the behavior of another function",
        "A type of comment",
        "A Python module for UI design"
      ],
      "correct_answer": 1,
      "description": "A decorator is a design pattern that allows you to modify or enhance functions or classes without directly modifying their source code. Decorators are callable objects that take a function as input and return a new function with added functionality.",
      "reference": "https://docs.python.org/3/glossary.html#term-decorator",
      "code": "def my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Before function call')\n        result = func(*args, **kwargs)\n        print('After function call')\n        return result\n    return wrapper\n\n@my_decorator\ndef say_hello(name):\n    print(f'Hello, {name}!')\n\nsay_hello('Alice')"
    },
    {
      "question": "What is the Global Interpreter Lock (GIL) in Python?",
      "hint": "It affects multithreading",
      "options": [
        "A security feature for global variables",
        "A mutex that protects access to Python objects",
        "A compiler optimization",
        "A debugging tool"
      ],
      "correct_answer": 1,
      "description": "The GIL is a mutex that protects access to Python objects, preventing multiple native threads from executing Python bytecodes simultaneously. This means that even on multi-core systems, only one thread can execute Python code at a time, which can be a bottleneck for CPU-bound multi-threaded programs.",
      "reference": "https://docs.python.org/3/glossary.html#term-global-interpreter-lock",
      "code": "# For CPU-bound tasks, use multiprocessing instead\nfrom multiprocessing import Pool\n\ndef square(x):\n    return x ** 2\n\nwith Pool(4) as p:\n    results = p.map(square, range(10))\n    print(results)"
    },
    {
      "question": "What is the difference between a shallow copy and a deep copy?",
      "hint": "Consider nested objects",
      "options": [
        "There is no difference",
        "Shallow copy creates a new object but references nested objects; deep copy creates completely independent copies",
        "Shallow copy is faster but less accurate",
        "Deep copy only works with dictionaries"
      ],
      "correct_answer": 1,
      "description": "A shallow copy creates a new object but inserts references to the objects found in the original. A deep copy creates a new object and recursively copies all objects it references. This matters for nested structures where modifying nested elements in a shallow copy affects the original.",
      "reference": "https://docs.python.org/3/library/copy.html",
      "code": "import copy\n\noriginal = [[1, 2, 3], [4, 5, 6]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)\n\nshallow[0][0] = 999\nprint(original)  # [[999, 2, 3], [4, 5, 6]] - modified!\n\ndeep[1][0] = 888\nprint(original)  # [[999, 2, 3], [4, 5, 6]] - unchanged"
    },
    {
      "question": "What is a generator in Python?",
      "hint": "It uses yield instead of return",
      "options": [
        "A function that creates random numbers",
        "A function that yields values lazily using the yield keyword",
        "A class constructor",
        "A type of loop"
      ],
      "correct_answer": 1,
      "description": "A generator is a function that returns an iterator using the yield keyword. Unlike regular functions that return all values at once, generators produce values one at a time, only when requested. This makes them memory-efficient for large datasets.",
      "reference": "https://docs.python.org/3/howto/functional.html#generators",
      "code": "def fibonacci(n):\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\n# Values are generated on-demand\nfor num in fibonacci(10):\n    print(num, end=' ')\n# Output: 0 1 1 2 3 5 8 13 21 34"
    }
  ]
}
